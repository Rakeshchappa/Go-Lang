package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strconv"
)

func main() {
	// API endpoint URL
	apiURL := "https://dummyjson.com/carts"

	// Fetch JSON data from the API endpoint
	resp, err := http.Get(apiURL)
	if err != nil {
		log.Fatalf("Error fetching JSON data: %v", err)
	}
	defer resp.Body.Close()

	// Decode JSON data into a map
	var jsonData map[string]interface{}
	err = json.NewDecoder(resp.Body).Decode(&jsonData)
	if err != nil {
		log.Fatalf("Error decoding JSON data: %v", err)
	}

	// Generate Go struct dynamically
	structDefinition := GenerateStruct("AutoGenerated", jsonData)

	// Print dynamically generated struct
	fmt.Println(structDefinition)
	fmt.Println("/////////////////////////////////")
}

// GenerateStruct generates Go struct dynamically
func GenerateStruct(name string, data map[string]interface{}) string {
	structStr := fmt.Sprintf("type %s struct {\n", name)

	for key, value := range data {
		fieldType := getFieldType(reflect.ValueOf(value))
		valueTag := getValueTag(value)
		// For nested structs or slices/interfaces, generate struct definition dynamically
		if fieldType == "slice" || fieldType == "map" {
			nestedStruct := GenerateNestedStruct(key, value)
			structStr += fmt.Sprintf("\t%s\t%s `%s`\n", key, nestedStruct, "json:\""+key+valueTag+"\"")
		} else {
			structStr += fmt.Sprintf("\t%s\t%s `%s`\n", key, fieldType, "json:\""+key+valueTag+"\"")
		}
	}

	structStr += "}\n"
	return structStr
}

// GenerateNestedStruct generates a nested struct dynamically
func GenerateNestedStruct(name string, data interface{}) string {
	switch v := data.(type) {
	case []interface{}:
		structStr := "[]struct {\n"
		if len(v) > 0 {
			elemType := getFieldType(reflect.ValueOf(v[0]))
			if elemType == "map" {
				for _, elem := range v {
					elemStruct := generateStructFromMap(elem.(map[string]interface{}))
					structStr += elemStruct
				}
			} else {
				structStr += fmt.Sprintf("\t%s\t%s `%s`\n", "Elem", elemType, "json:\""+name+"\"")
			}
		}
		structStr += "}\n"
		return structStr
	case map[string]interface{}:
		return generateStructFromMap(v)
	case float64:
		return "float64"
	}
	return ""
}

// generateStructFromMap generates a struct definition from a map
func generateStructFromMap(data map[string]interface{}) string {
	structStr := "struct {\n"
	for key, value := range data {
		fieldType := getFieldType(reflect.ValueOf(value))
		valueTag := getValueTag(value)
		if fieldType == "map" {
			nestedStruct := generateStructFromMap(value.(map[string]interface{}))
			structStr += fmt.Sprintf("\t%s\t%s `%s`\n", key, nestedStruct, "json:\""+key+valueTag+"\"")
		} else if fieldType == "slice" {
			nestedStruct := GenerateNestedStruct(key, value)
			structStr += fmt.Sprintf("\t%s\t%s `%s`\n", key, nestedStruct, "json:\""+key+valueTag+"\"")
		} else {
			structStr += fmt.Sprintf("\t%s\t%s `%s`\n", key, fieldType, "json:\""+key+valueTag+"\"")
		}
	}
	structStr += "}\n"
	return structStr
}

// getFieldType returns the Go type of a field
func getFieldType(field reflect.Value) string {
	switch field.Kind() {
	case reflect.String:
		return "string"
	case reflect.Float64:
		return "float64"
	case reflect.Bool:
		return "bool"
	case reflect.Slice:
		return "slice"
	case reflect.Map:
		return "map"
	case reflect.Struct:
		return field.Type().Name()
	default:
		return "interface{}"
	}
}

// getValueTag returns the value of a field as a string for the struct tag
func getValueTag(value interface{}) string {
	switch v := value.(type) {
	case float64:
		return "::" + strconv.FormatFloat(v, 'f', -1, 64)
	case string:
		return "::\"" + v + "\""
	case bool:
		return "::" + strconv.FormatBool(v)
	default:
		return ""
	}
}
