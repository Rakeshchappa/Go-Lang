package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
)

func main() {
	// API endpoint URL
	apiURL := "https://dummyjson.com/carts"

	// Fetch JSON data from the API endpoint
	resp, err := http.Get(apiURL)
	if err != nil {
		log.Fatalf("Error fetching JSON data: %v", err)
	}
	defer resp.Body.Close()

	// Decode JSON data into a map
	var jsonData map[string]interface{}
	err = json.NewDecoder(resp.Body).Decode(&jsonData)
	if err != nil {
		log.Fatalf("Error decoding JSON data: %v", err)
	}

	// Generate Go struct dynamically
	structDefinition := GenerateStruct("AutoGenerated", jsonData)

	// Print dynamically generated struct
	fmt.Println(structDefinition)
}

// GenerateStruct generates Go struct dynamically
func GenerateStruct(name string, data map[string]interface{}) string {
	structStr := fmt.Sprintf("type %s struct {\n", name)

	for key, value := range data {
		fieldType := getFieldType(reflect.ValueOf(value))
		// For nested structs or slices/interfaces, generate struct definition dynamically
		if fieldType == "slice" || fieldType == "map" {
			nestedStruct := GenerateNestedStruct(key, value)
			structStr += fmt.Sprintf("\t%s\t%s `%s`\n", key, nestedStruct, "json:\""+key+"\"")
		} else {
			structStr += fmt.Sprintf("\t%s\t%s `%s`\n", key, fieldType, "json:\""+key+"\"")
		}
	}

	structStr += "}\n"
	return structStr
}

// GenerateNestedStruct generates a nested struct dynamically
func GenerateNestedStruct(name string, data interface{}) string {
	switch v := data.(type) {
	case []interface{}:
		if len(v) == 0 {
			return "[]string"
		}

		elemType := getFieldType(reflect.ValueOf(v[0]))
		if elemType == "map" {
			return "[]" + generateStructFromMap(name, v[0].(map[string]interface{}))
		}
		return "[]" + elemType
	case map[string]interface{}:
		return generateStructFromMap(name, v)
	case float64:
		return "int"
	case string:
		return "string"
	}
	return ""
}

func generateStructFromMap(name string, data map[string]interface{}) string {
	structStr := fmt.Sprintf("struct {\n")
	for key, value := range data {
		fieldType := getFieldType(reflect.ValueOf(value))
		if fieldType == "map" {
			nestedStruct := generateStructFromMap(key, value.(map[string]interface{}))
			structStr += fmt.Sprintf("\t%s\t%s\n", key, nestedStruct)
		} else if fieldType == "slice" {
			nestedStruct := GenerateNestedStruct(key, value)
			structStr += fmt.Sprintf("\t%s\t%s\n", key, nestedStruct)
		} else {
			structStr += fmt.Sprintf("\t%s\t%s `%s`\n", key, fieldType, "json:\""+key+"\"")
		}
	}
	structStr += "}\n"
	return structStr
}

// getFieldType returns the Go type of a field
func getFieldType(field reflect.Value) string {
	switch field.Kind() {
	case reflect.String:
		return "string"
	case reflect.Float64:
		return "float64"
	case reflect.Bool:
		return "bool"
	case reflect.Slice:
		return "slice"
	case reflect.Map:
		return "map"
	case reflect.Struct:
		return field.Type().Name()
	default:
		return "interface{}"
	}
}
